<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
  <link rel="stylesheet" href="style.css">
  <link rel="stylesheet" href="style1.css">
  <link rel="stylesheet" href="style2.css">
  <link rel="stylesheet" href="style3.css">
  <link rel="stylesheet" href="style4.css">
  <link rel="stylesheet" href="style5.css">
  <link rel="stylesheet" href="style6.css">

</head>


  <body>
      <nav>
          <h1 class="logo"> C Programming Language Tutorial </h1>
          <button><a href="index.html">Home</a></button> 
          <button><a href="index.html">Practice Question</a></button>
          <button><a href="index.html">objective</a></button>
          <button><a href="index.html">About</a></button> 
          <button><a href="index.html">Author Profile</a></button>
            
      
      </nav>


  
      <div class="step4">
        <h1 style="text-align: center; font-size: 40px; margin-right: 150px; color: white;">UNIT - 1</h1>
         
        <h1>Q.1. What is programming Language ? Describe Classification of programming language.</h1>
            <h2>Computer Language </h2> 
               <p> Once the planning for a computer program has been done, the next step in its devlopment is to write the specific steps for solving the problem at hand in a language and make a form, which is acceptable
                   to a computer system. 
               </p> <br>     
               <p>
                   A language that is acceptable to a computer system is called a computer language or a programming
                   language. The process of writing instractions in a computer language for an already planned program 
                   is called programming or coding. Computer languages are used fpr writing computer programs.
               </p>
               <h2>Different Levels of Computer Programming Language</h2>
                <b>1. High level programming language</b><br>
                <b>2. Low level programming language</b><br><br>
                
                <h2>High level programming language :-</h2>
                <p>High level language have been designed to give a better programming efficiency.</p><br>
                <b>Key features :</b>
                <p>1.  Problem oriented language</p>
                <p>2.  Faster program devlopment</p><br>
                
                <p>High level language permits humans to write complex programming without going step by step. one 
                    command in a high-level language may translate to tens of machine language instractions.
                    High level language are application oriented. This is simplest and most widely used language
                    for application devlopment which overcomes the problem associated with assembly languages.
                    High level language is independent of the structure of the computer.  
                </p>
    
                <p>One instruction gets translated into many machine language instruction. It needed a translator 
                    to translate high-level language to machine code (i.e. computer and interpreter). This language
                    allow the exprassion of the program to be at a more "natural" level.
                </p>
                <h2>For example</h2>
                <p>A = B*C+10 Looks more like mathematical notation</p>
                <p>In this language, statements are more clearly assemble English and mathematics than mnemonics.
                    Instructions written in high-level language are called statement rather than mnemonics.
                </p>
    
                <h2>Example of High-level language</h2>
                <p>1.  BASIC <br>  2.  COBOL <br>  3.  PASCAL <br> 4.  ALGOL <br>  5.  FORTRAN</p>
    
                <h2>Advantage of high level language:</h2>
                <p>1. High-level languages are machine independent.</p>
                <p>2. High-level language instruction are very clear.</p>
                <p>3. Easier and faster to write a program.</p>
                <p>4. Program written in high level language are portable.</p>
                <p>5. high-level language use standard syntax.</p>
                <p>6. Fever errors.</p>
                <p>7. Modification is easier and straight forward.</p>
                <p>8. Easier documentation and maintenance.</p>
                <p>9. Programs are independent of the internal structure of a computer.</p>
    
                <h2>Disadvantage of High-level language</h2>
                <p>1. Programmer need to know about standard rules for writing a program in high level language.</p>
                <p>2. program written in high-level language have lower efficiency.</p>
                <p>3. High level language programs are less flesible.</p>
                <!-- <p>4. High level language program requires a compiler which causes large memory space inside main 
                    memory at the time of execution of a program.</p> -->
                <p>4. Required compiler is expensive.</p>
                <p>5. Expensive hardware and software supports are required.</p>
                <p>6. Compilation time is more due to low speed.</p>
    
                
                <h2>Low level programming language</h2>
                <p>Low level language have been designed to give a bettter machine efficiency.</p><br>
                <b>Key features:</b>
                <p>1. Machine oriented language</p>
                <p>2. Faster program execution</p><br>
                <b>Examples:</b>
                <p>1. Assembly Language</p>
                <p>2. Machine Language</p>
    
                <h2>Machine Language</h2>
                <p>Machine language is binary codes that the computer execute. Sometimes it is referred as machine code 
                    or object code.</p><br>
                    <p>Machine language is a collection of binary digits or bits that the computer reads and interpreters.
                        Machine language is the only language a computer is capable of understanding.It is the native 
                        language of the computer.</p><br>
                        <p>In order for a program to run, it must be presented to the computer as binary coded machine 
                            instructions that are specific to that CPU model or family.</p><br>
                            <p>Althrough programmers are Sometimes able to modify machine language in order to fix 
                                a running program, they do not create it.</p><br>
                                <p>Machine language is created by programs called "assemblers", "compilerrs" and 
                                    "interpreters" which convert the lines of programming code a human writes into the 
                                    machine language the computer understands.
                                </p><br>
                                <p>Machine language tells the computer what to do and where to do it. When a 
                                    programmer writes TOTAL = TOTAL + SUBTOTAL, that statement is converted into a machine 
                                    instruction that tells the computer to add the contents of the two areas of memory 
                                    where TOTSL snd SUBTOTAL are stored and put the result in TOTAL.
                                </p>
    
                                <H2>Advantage</H2>
                                <P>1. Machine language tells the computer what to do and where to do it.</P>
                                <p>2. Programs written in machine language are specific to that CPU. So that program
                                    runs very fast in the absence of compiler (i.e. it is not needed)
                                </p>
    
                                <h2>Disadvantage</h2>
                                <p>1. Machine language is machine dependent.</p>
                                <p>2. Prgrammers are Sometimes able to modify machine language.</p>
                                <p>3. It requires high level of programming skill. </p>
                                <p>4. Highly error prone.</p><br>
    
                                <p>A programmer deals with data logically, "add this, subtract that", but the computer
                                    must be told precisely where this and that are located.
                                </p><br>
    
                                <p>The machine language is recommended in the following situations:</p><br>
                                <p>1. When we require to processes simple control application.</p>
                                <p>2. suitable for small and simple program where less computation is required.</p>
                                <p>3. Some applications where prototype is the final product.</p>
    
                                <h2>Assembly language</h2>
                                <p>An assembly language is the low level programming language designed for specific processors.</p>
                                <p>Assembly language uses structured commands as sub-stitutions for numbers allowing humans 
                                    to read the code easier then looking at binary. Most high level programming languages convert
                                    the code to assembly language when they are compiled. 
                                </p><br>
    
                                <p>Example of assembly language code.</p>
                                <p>mov ax, 4COOh <br> int 21h <br> Assembly language is a mnemonics form of machine
                                language.</p><br>
                                <b>Mnemonic-</b>
                                <p>Symbolic words used in assembly language are referred to as mnemonics.</p>
    
                                <h2>Advantage</h2>
                                <p>1. Assembly language is the easy way to write machine language.</p>
                                <p>2. Efficient in terms of machine language program output.</p>
                                <p>3. It offers great flexibility in writing program because all hardware features available
                                    inside the processor.</p>
                                <p>4. Easy to trace and debug errors.</p>    
                                <p>5. Not required to keep track of memory locations.</p>
    
                                <h2>Disadvantage</h2>
                                <p>1. It is a machine specific language.</p>
                                <p>2. To program in assembly you need to understands concepts behind machine language and 
                                    execution-fetch cycle of CPU.</p>
                                <p>3. Each line of an assembly language generates one machine language instruction.</p>    
                                <p>4. writing assembly language program is difficult and time consuming.</p>
                                <p>5. Program written in one computer can not be executed on another.</p>
    
    
                                <h2>The assembly language is recommended in the following situations:</h2>
                                <p>1. When we require to processes small volume of data.</p>
                                <p>2. When we have to work with real time control applications.</p>
                                <p>3. This language may be preferred when the cost of the memory is under consideration.</p>
                                <p>4. This is the best language to be used where fewer computatons are required.</p>
                                <p>5. suitable language for industrial applications.</p>
                                <p>6. Can be used efficiently while developing a program for microprocessor based system.</p>
    
                                <h2>Differences between Assembly language anf machine language:</h2>
                                <p>Althrough Assembly and machine language might look similar, they are in fact two 
                                    different types of language.
                                </p>
                                <p>1. Assembly consists of both binary and simple words.</p>
                                <p>2. Machine code composed only of 0's and 1's.</p>
        <div class="hr">
         <h1>New Question</h1>
        </div>  
        
                <h1>Q.2. What is Object Oriented Programming ? How is it different from procedure oriented programming.</h1>                            
    
                <br><p>Object oriented Programming is an approach that provides a way of Modularizing programs by creating
                    partitioned memory area for both data and Junctions that can be used as templates for creating copies 
                    of such modulesh on demand. Thus, an object is considered to be a partitioned area of computer memory
                    that store data and set of operations that can access that data. Since the memory partitions are independent,
                    the objects can be used in a variety of different programs without Modifications.
                </p><br>
                <p>It lies data more closely to the functions that operate on it. and protects it from accidental 
                    Modification from outside functions. OOP allows decomposition of problem into a number of entities
                    called objects and then bullets data and functions around these objects.
                </p><br>
                <p>The major Differences between OOP and procedure-Oriented programming are as follows:
    
                </p><br>
                <table border="1" class="tab">
                    <tr>
                        <th style="color: red;">S.No.</th>
                        <th style="color: red;">Procedure oriented programming</th>
                        <th style="color: red;">Object oriented programming</th>
                    </tr>
    
                    <tr>
                        <td>1.</td>
                        <td>It emphasizes on data rather then procedure</td>
                        <td>It emphasizes on doing things or algorithms.</td>
                    </tr>
    
                    <tr>
                        <td>2.</td>
                        <td>Programs are decomposed into objects</td>
                        <td>Large programs are decomposed into functions.</td>
                    </tr>
    
                    <tr>
                        <td>3.</td>
                        <td>Data structures used characterize the objects</td>
                        <td>Most of the functions share global data.</td>
                    </tr>
    
                    <tr>
                        <td>4.</td>
                        <td>Data is hidden and cannot be accessed by external functions</td>
                        <td>Data move openly around the system from function to function.</td>
                    </tr>
    
                    <tr>
                        <td>5.</td>
                        <td>OOP follows bottom-up approach in program design</td>
                        <td>POP follows top-down approach in program design</td>
                    </tr>
                </table><br>
    
        <div class="hr">
          <h1>New Question</h1>
       </div>
             
          
            <h1>Q.3. Explain in detail the Procedural(Structured) oriented Vs Object Oriented Programming paradigm.</h1><br>
            <h2>Procedural(Structured) oriented Programming paradigm</h2>
            <p>Procedural programming is a programming paradigm built around the idea that programs are sequences of 
                instructions to be executed. They focus heavily on splitting up programs into named sets of instructions
                 called procedures, analogous to functions. A procedure can store local data that is not accessible from 
                 outside the procedure's scope and can also access and modify global data variables.</p><br>
    
                <p>Some of the earliest procedural programming languages were Fortran and ALGOL. Ideas developed in ALGOL
                 are very much relevant and prevalent in modern-day programming languages.</p><br>
                
                <h2>What are some tenets of procedural programming?</h2>
                <p>1. Programs are composed of sequences of instructions. Minimal abstraction is present between the code and the machine.</p>
                <p>2. Procedures, which are logical blocks consisting of groups of instructions, can be invoked from other places in the code.</p>
                <p>3. A procedure can accept arguments and return values to the caller. Additionally, functions can access and modify 
              variables in the global scope. </p>
                <p>4. languages follow structured programming practices and use block-based control flow rather than goto commands.</p>
            
            <h2>Object Oriented Programming paradigm</h2>
            <p>The object-oriented (OO) paradigm took its shape from the initial concept of a new programming approach, while the 
                interest in design and analysis methods came much later. OO analysis and design paradigm is the logical 
                result of the wide adoption of OO programming languages.</p>    
            
            
            <p>O paradigm is a significant methodology for the development of any software. Most of the architecture 
                styles or patterns such as pipe and filter, data repository, and component-based can be implemented by
                 using this paradigm.</p><br>
    
                <p>concepts and terminologies of object–oriented systems −</p>    
            
            <h2>Object</h2>
            <p>An object is a real-world element in an object–oriented environment that may have a physical or a
                 conceptual existence. Each object has −</p><br>
                 <p>1. dentity that distinguishes it from other objects in the system.</p>
    
                    <p>2. State that determines characteristic properties of an object as well as values of properties that the object holds.</p>
                    
                    <p>3. Behavior that represents externally visible activities performed by an object in terms of changes in its state.</p>    
            
                <br><p>Objects can be modeled according to the needs of the application. An object may have a physical existence, like a customer,
                     a car, etc.; or an intangible conceptual existence, like a project, a process, etc.</p> 
                    
                
                <br><h2>Class</h2>     
                <p>A class represents a collection of objects having same characteristic properties that exhibit common
                     behavior. It gives the blueprint or the description of the objects that can be created from it. 
                     Creation of an object as a member of a class is called instantiation. Thus, an object is an instance 
                     of a class.</p><br>
    
                    <p>The constituents of a class are −</p><br>
                    
                    <p>1. A set of attributes for the objects that are to be instantiated from the class. Generally, different
                         objects of a class have some difference </p>
                         <P>in the values of the attributes. Attributes are often referred as class data.</p><br>
                    
                    <p>2. A set of operations that portray the behavior of the objects of the class. Operations are also referred as functions or methods.</p>
                    
                    <h2>Example</h2>       
                    <p>Let us consider a simple class, Circle, that represents the geometrical figure circle in a two–dimensional
                         space. The attributes of this class can be identified as follows −</p><br>
    
                        <p>1. x–coord, to denote x–coordinate of the center</p>
                        <p>2. –coord, to denote y–coordinate of the center</p>
                        <p>3. a, to denote the radius of the circle</p><br>
    
                        <p>Some of its operations can be defined as follows −</p><br>
                        
                        <p>1. findArea(), a method to calculate area</p>
                        <p>2. findCircumference(), a method to calculate circumference</p>
                        <p>3. (), a method to increase or decrease the radius</p>
                        
        <div class="hr">
            <h1>New Question</h1>
        </div>
    
                    <h1>Q.4. Explain in details the Structured Programming Concept.</h1><br>
                    <p>Structured programming, or modular programming, is a programming paradigm that facilitates the creation of
                         programs with readable code and reusable components. All modern programming languages support structured 
                         programming, but the mechanisms of support -- like the syntax of the programming languages -- vary.</p><br>
                   
    
                         <p>When modules or elements of code can be reused from a library, it may also be possible to build
                             structured code using modules written in different languages, as long as they can obey a common 
                             module interface or application program interface specification. However, when modules are reused, i
                             t's possible to compromise data security and governance, so it's important to define and enforce a 
                             privacy policy controlling the use of modules that bring with them implicit data access rights.</p>
                      
    
                             <h2>Difference between structured and unstructured programming languages</h2>
                                <p>A structured programming language facilitates or enforces structured programming practices. Unstructured languages 
                                can also support these practices, but that requires specific steps in program design and implementation. Structured 
                                programming practices thus date to the emergence of structured programming languages.</p><br>
                                
                                <p>The theoretical basis for structured programming goes back to the 1950s, with the emergence of Algorithmic Language 
                                (ALGOL) 58 and 60. Up to then, code clarity was reduced by the need to build condition/action tests by having
                                 programmers write linked tests and actions explicitly -- using the goto statement or its equivalent -- resulting 
                                 in what was often called spaghetti code. ALGOL included block structure, where an element of code included a condition and an action.</p>
                            
                            
                                 <h2>Types of structured programming</h2>
                                <p>There are three categories of structured programming:</p><br>
    
                                <b>1. Procedural programming.</b>
                                <p>Defines modules as procedures or functions that are called with a set of parameters to
                                   perform a task. A procedural language begins a process, which is then given data. It is also the 
                                   most common category and is subdivided into the following:</p><br>
                                <p>a. Service-oriented programming simply defines reusable modules as services with advertised interfaces.</p><br>
                                <p>b. Microservice programming focuses on creating modules that do not store data internally and so are scalable </p>
                                <p>and resilient in cloud deployment.</p><br>
                                <p>c. functional programming, technically, means that modules are written from functions, and that these functions' outputs</p>
                                 <p> are derived only from their inputs. Designed for serverless computing, the definition of functional programming has since expanded to be largely synonymous with microservices.</p><br>
                                <b>2. Object-oriented programming (OOP). </b><br>
                                <p>Defines a program as a set of objects or resources to which commands are sent. An object-oriented language defines a data resource and sends it to process commands. For example, the procedural programmer might say, "Print(object)," while the OOP programmer might say, "Tell Object to Print."</p><br>
                                <b>3. Model-based programming.</b><br>
                                 <p>The most common example of this is database query languages. In database programming, units of code are associated with steps in database access and update or run when those steps occur. The database and database access structure determine the structure of the code. Another example of a model-based structure is Reverse Polish notation, a math-problem structure that lends itself to efficient solving of complex expressions. Quantum computing is another example of model-based structured programming; the quantum computer demands a specific model to organize steps, and the language simply provides it.</p>
    
    
    
                                 <h2>Advantages of structured programming</h2>
                                    <p>There are multiple advantages to structured programming. For one, it encourages top-down implementation, which improves both readability and maintainability of code. Structured programming also promotes code reuse, since even internal modules can be extracted and made independent, residents in libraries, described in directories and referenced by many other applications. Lastly, it's widely agreed that structured programming improves development time and code quality.</p><br>
    
                                    <p>These advantages are normally seen as compelling -- even decisive -- and nearly all modern software development employs structured programming.</p>
    
                                    <h2>Disadvantages of structured programming</h2>
                                    <p>The biggest disadvantage of structured programming is a reduction in execution efficiency, followed by greater memory usage. Both these problems arise from the introduction of calls to a module or process, which then returns to the caller when it's done. System parameters and system resources are saved on a stack -- a queue organized as LIFO, or last in, first out -- and popped when needed. The more program logic is decomposed, meaning the more modules are involved, the greater the overhead associated with the module interface. All structured programming languages are at risk to overstructuring and loss of efficiency.</p><br>
    
                                    <p>Structured programming can also be applied incorrectly if the type of structure selected isn't right for the task at hand. The best-known example is the solving of math problems. RPL is an efficient way to state and solve a math problem because it eliminates the need to explicitly state execution order and eliminates recursion in code. However, if that problem were to be posed in structured programming procedural or object form, the resulting code would be much less efficient than the RPL version.</p>
    
    
              
            <div class="hr">
                 <h1>New Question</h1>
             </div>
              
              
                            <h1>Q.5. Explain the Logic development & Problem solving.</h1><br>
                            <p>Problem solving through computer is a creative and challenging process. It requires a careful study of the problem.
                                In problem solving we need to understand the givan problem clearly in terms of requirements such as input and output.
                                Then we can decide which operations to be performed.
                            </p>
    
                            <h2>Steps involved i problem solving</h2>
                            <p>1. Define the problem.</p>
                            <p>2. analyze the problem.</p>
                            <p>3. Develop an algorithm (a method) for solving the problem. </p>
                            <p>4. Write the computer program which implements the algorithm.</p>
                            <p>5. Test and debug (find the errors in) the program.</p>
                            <p>6. document the program.</p>
                            <p>7. maintain the program.</p>
    
                            <h2>Problem Solving strategies</h2>
                            <p>1. Working backwards.</p>
                            <p>2. Look for a related problem that has been solved before .</p>
                            <p>3. Stepwise Refinement.</p>
                            <p>4. K.I.S.S = Keep it simple Stupid!</p>
    
                            <h2>Problem Identification</h2>
                            <p>software can be developed using programming language. software is analyzed in term of a problem to be solved. Problem solving involved many steps. Problem definition is one of them.
                                This step describes what we have to do rather than how. Exact specification are mentioned during problem definition step. Identification of problem is done before problem definition. Problem has to be identified before making thire 
                            definitions. This is the first step in computer problem solving. The problem solver should identify the problem before specifying the requirements. </p>
                            
                            <h2>Problem Definition</h2>
                            <p>To solve a particular Problem, first of all we need to define the problem under consideration. Solution involves problem definition as a key step. Any computer in the world can not do anything without problem definition.</p><br>
                            <p>Problem are viewed in terms of requirements. Requirements may be input and output opereations to be performed. programmer's job is to convert the problem in such a way that it is easily understood by the computer. Programmer 
                                can define a well defined set of statement to get the desired solution from a problem. </p><br> 
    
                             <p>While dividing a problem into smaller modules, following points should be remember.</p><br>
                             <p>1. The problem solver should understand the problem in terms of requirements.</p>
                             <p>2. problem should be properly interpreted.</p>
                             <p>3. Ambiguity should not be exist in problem definition.</p>
                             <p>4. It should be defined clearly</p>
                             <p>5. The programmer should extract well defined statements from prob lem definition.</p>
                             <p>6. After problem definition, precise tasks should be carried out.</p>
    
                             <h2>analysis</h2>
                             <p>Analysis means understanding what we are dealing with. Before we can design a solution, 
                                we need to be clear about the relevent entities, thire properties and their inter relationships.
                                 we also need to be able to verify our understanding. This can involve customers and end users, since 
                                 they're likely to be subject matter experts. The sorts of question we ask during the analysis phase are 
                                 "What products do we sell in this shop ? Where do they come from ? How much do they cost ? </p><br>
                             
                                 <p>Any problem may be solved only after its analysis phase. Problem analysis is helpful to determine : </p>
                                 <p>1. Data items</p>
                                 <p>2. Their data types</p>
                                 <p>3. Relationships between them</p>
                                 <p>4. operations to be performed on them</p>
                                 <p>5. Memory execution time</p><br>
                                 
                                 <p>It is the phase of programming in which we understand the requirement of the problem to be solved and their solution. The 
                                    output of the analysis phase feed into  the coding phase. Problem analysis involve following key points in their phase.
                                 </p>
                                 <p>1. Requirements related to input and output of the problem.</p>
                                 <p>2. Implementation requiment</p>
                                 <p>3. Time constraints</p>
                                 <p>4. Interface in between the process </p>
                                 <p>5. Storage limitation</p>
                                 <p>6. Error handling and accuracy</p><br>
    
                                 <h2>We futher analyze the problem to :</h2>
                                 <p>a. Ensure that we have the clearest possible understanding of it.</p><br>
                                 <p>b. Determine general requirements such as the main inputs to the program and the main outputs from the program. For more 
                                 complex programs. we would, for instance, also need to decide on the kinds of files which may be needed.
                                 </p><br>
                                 <p>If there are several ways to solve the problem, we should consider the alternatives and choose the best or most appropriate one.</p>
    
                                 <h2>Design</h2>
                                 <p> In the design phase, we work out how to solve the problem. In other words, we make decisions, based on experience, estimation and intuition, about what software we will write and how we will deploy 
                                    it. System design breaks the system down into logical subsystem (proccesses) and physical subsystem (computers and networks), decides how machines will communicate, and chooses the right technologies for the job, and so on. The sort of decision we make during 
                                    the system design phase is we're going to use an intranet and the java messaging Services for communication sales results to head office. In subsystem design we decide how to cut each logical subsystem into effective, efficient and feasible code. The sort of decision we make during the subsystem design phase is 
                                    "Line items in an inventory are implemented a hash table, keyed by part number".
                                 </p>
    
                                 <h2>Coding</h2>
                                 <p>The design must be translate into a machine readable form. The coding step performs this task. If design is performed in a detailed manner, coding can be accomplished mechanisically.</p><br>
                                 <p>In the modern software devlopment style, coding is regarded as only a small part of the overall software devlopment activities. There are several devlopment activities such as design and testing which typically require much more effort than coding.</p><br>
                                 <p>In the exploratory style, coding was considered synonymous with software development. For instance, exploratory programming style believed in devloping a working system as quickly as possible and then successively modifying it until it performed satisfactority  </p><br>
                                 <p>During coding phase, the software requiment specification (SRS) document produred. </p>
    
                                 <h2>Testing</h2>
                                 <p>When our software is complete, it must be tested against the system requiments to see if it fits the original goals. The sort of question we ask during the testing phase is 'can a shop assistant use the till interface to sell a toaster, decreasing the product's in ventory as a side effect?' As well as this kind of conformance testing it's 
                                    a good idea to see if our software can be broken via its external interfaces - this helps to product us against accidental or malicious abuse of the system when it's been deployed.
                                 </p><br>
                                 <p>It is a good idea for programmers to perform small tests as they go along, to improve the quality of the code that they deliver. Generally speaking, however, major tests should not be designed, implemented or carried out by the devlopers who wrote the software. To understand why, consider buying a new house and spending vast amounts of time 
                                    and money refurbishing it from top to bottom. It's unlikely that you would want to whack the structures and fixtures with a sldgehammer to see if they're durable, ask passing strangers whether they think that you have good taste or pretend to be a burglar to see if you can break in. These are exactly the kinds of things that we need to be doing during software testing. 
                                 </p>
    
                                 <h2>Debugging</h2>
                                 <p>Programming is a skill that can be obtained only through study and experience. The newcomer to C or to programming in general has to recognize that fact that errors are bound to occur. In programming circles, errors are known as bugs, possibly because they seem to creep undetected into every program. The process of finding and eliminating buts is known as Debugging. </p><br>
                                 <p>When our software misbehaves, we can check whether the implementation matches the specification. Thus we have a start ing point for identifying and removing faults. Debugging is a process of finding and reducing the number of bugs , or defects, in a computer program, thus making it behave as expected . Debugging tends to be harder when various subsystem are tightly coupled, as changes in one may cause bugs to emerge in another.</p>
    
                                 <h2>Implementation</h2>
                                 <p>Implementation is nothing but the writing pieces of code that work together to form subsystem, which in turn collaborate to form the whole system . The sort of task we carry out during the implementation phase is "write the method bodies for the inventory class, in such way that they conform to their specification". Althrough we would expect most of the difficult implementation decisions to have been made before we reach design phase, 
                                    there is still plenty fo scope for creativity: althrough the public interfaces of our software component will have been well designed, specified and documented, programmers have free rein to decide on the inner workings. As long as the end result is effective and correct, everyone will be happy. 
                                 </p>
    
                                 <h2>Maintanace & Modification</h2>
                                 <p>Modification of a software product required after delivery to correct faults, to improve performance or other attributes.</p><br>
                                 <p>Modification has become the responsibility of the maintenance group. The maintenance programmer must analyze each request, confirm it by reproducing the situation and check its validity, investigate it and propose a solution, document the request and the solution proposal, and finally, obtain all the required authorizations to apply the Modifications.</p><br>
                                 <p>software maintenance in software engineeringis the Modification of a software product after delivery to correct faults, to improve performance or other attributes, or to adept the product to a modified environment.</p><br><br><br><br><br>
    
    
    </div>
           
                                 
    
           
           <button class="btn-unit2">
            <a href="unit2.html">Unit 2</a>
           </button><br><br>
  
      <footer class="step2">
          <h1>C Programming Language Tutorial</h1>
          <a href="index.html">Home</a>
          <a href="#">Practice Question</a>
          <a href="#">Objective</a>
          <a href="#">About</a>
          <a href="#">Author Profile</a><br><br><br><br><br><br>
          
          
       </footer>
      
  
      
  </body>
  </html>
  
</body>
</html>